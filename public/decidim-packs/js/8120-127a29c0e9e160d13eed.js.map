{"version":3,"file":"js/8120-127a29c0e9e160d13eed.js","mappings":"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","sources":["webpack://decidim-development-app/./node_modules/@decidim/decidim-bulletin_board/src/client/graphql-client.js","webpack://decidim-development-app/./node_modules/@decidim/decidim-bulletin_board/src/client/message-identifier.js","webpack://decidim-development-app/./node_modules/@decidim/decidim-bulletin_board/src/client/message-parser.js","webpack://decidim-development-app/./node_modules/@decidim/decidim-bulletin_board/src/election/election.js","webpack://decidim-development-app/./node_modules/@decidim/decidim-bulletin_board/src/vote/vote.component.js","webpack://decidim-development-app/./node_modules/@decidim/decidim-bulletin_board/src/voter/voter.js","webpack://decidim-development-app/./node_modules/@decidim/voting_schemes-dummy/src/voter_wrapper.js","webpack://decidim-development-app/./node_modules/@decidim/voting_schemes-dummy/src/voter_wrapper_adapter.js","webpack://decidim-development-app/./node_modules/@decidim/voting_schemes-electionguard/src/wrapper_adapter.js","webpack://decidim-development-app/./node_modules/@decidim/voting_schemes-electionguard/src/voter_wrapper_adapter.js"],"sourcesContent":["import { ApolloClient, InMemoryCache, HttpLink } from \"@apollo/client/core\";\n\nimport GET_ELECTION_LOG_ENTRIES from \"./operations/get_election_log_entries\";\nimport PROCESS_KEY_CEREMONY_STEP from \"./operations/process_key_ceremony_step\";\nimport PROCESS_TALLY_STEP from \"./operations/process_tally_step\";\nimport GET_LOG_ENTRY from \"./operations/get_log_entry\";\nimport GET_PENDING_MESSAGE_BY_MESSAGE_ID from \"./operations/get_pending_message_by_message_id\";\n\n/**\n * This is the Bulletin Board API client that will use Apollo's client to\n * interact with our GraphQL schema using both http and websocket connections.\n */\nexport class GraphQLClient {\n  /**\n   * Initializes the class given the correct params. Since we need to handle\n   * both http and websocket connections we need to create two links and use either\n   * of them depending on the GraphQL operation.\n   *\n   * @constructor\n   * @param {Object} params - An object that include the following options.\n   *  - {String} apiEndpointUrl - The http endpoint used to perform queries and mutations.\n   *  - {Object?} headers - An optional object of headers to be included on http requests.\n   */\n  constructor({ apiEndpointUrl, headers }) {\n    const httpLink = new HttpLink({\n      uri: apiEndpointUrl,\n      headers,\n    });\n\n    this.apolloClient = new ApolloClient({\n      link: httpLink,\n      cache: new InMemoryCache(),\n    });\n  }\n\n  /**\n   * Query a log entry for the given election unique id and the given content hash.\n   *\n   * @param {Object} params - An object that includes the following options.\n   *  - {String} electionUniqueId - The election's unique id.\n   *  - {String} contentHash - The log entry content hash.\n   * @returns {Promise<Array<Object>>} - A log entry.\n   * @throws Will throw an error if the request is rejected.\n   */\n  async getLogEntry({ electionUniqueId, contentHash }) {\n    const result = await this.apolloClient.query({\n      query: GET_LOG_ENTRY,\n      variables: {\n        electionUniqueId,\n        contentHash,\n      },\n    });\n    return result.data.logEntry;\n  }\n\n  /**\n   * Query all log entries for the given election unique id.\n   *\n   * @param {Object} params - An object that include the following options.\n   *  - {String} electionUniqueId - The election's unique id.\n   *  - {String} after - The last log entry id received, to avoid including those entries again.\n   *  - {Array<String>} types - The list of type of messages to retrieve.\n   * @returns {Promise<Array<Object>>} - A collection of log entries.\n   * @throws Will throw an error if the request is rejected.\n   */\n  async getElectionLogEntries({ electionUniqueId, after, types }) {\n    const result = await this.apolloClient.query({\n      query: GET_ELECTION_LOG_ENTRIES,\n      variables: {\n        electionUniqueId,\n        after,\n        types,\n      },\n      fetchPolicy: \"no-cache\",\n    });\n\n    return result.data.election.logEntries;\n  }\n\n  /**\n   * Process a key ceremony step sending a signed message.\n   *\n   * @param {Object} params - An object that include the following options.\n   *  - {String} messageId - The message id.\n   *  - {String} signedData - The signed data to be processed.\n   * @returns {Promise<Object>} - A pending message created.\n   * @throws Will throw an error if the request is rejected or the data contains an error.\n   */\n  async processKeyCeremonyStep({ messageId, signedData }) {\n    const result = await this.apolloClient.mutate({\n      mutation: PROCESS_KEY_CEREMONY_STEP,\n      variables: {\n        messageId,\n        signedData,\n      },\n    });\n\n    if (result.data.processKeyCeremonyStep.error) {\n      throw new Error(result.data.processKeyCeremonyStep.error);\n    }\n\n    return result.data.processKeyCeremonyStep.pendingMessage;\n  }\n\n  /**\n   * Query PendingMessages for a given messageId\n   *\n   * @param {Object} params - An object that include the following options.\n   *  - {String} messageId - The messageId\n   * @returns {Promise<Object>} - The pending message received.\n   * @throws Will throw an error if the request is rejected.\n   */\n  async getPendingMessageByMessageId({ messageId }) {\n    const result = await this.apolloClient.query({\n      query: GET_PENDING_MESSAGE_BY_MESSAGE_ID,\n      variables: {\n        messageId,\n      },\n    });\n\n    return result.data.pendingMessage;\n  }\n\n  /**\n   * Process a tally step sending a signed message.\n   *\n   * @param {Object} params - An object that include the following options.\n   *  - {String} messageId - The message id.\n   *  - {String} signedData - The signed data to be processed.\n   * @returns {Promise<Object>} - A pending message created.\n   * @throws Will throw an error if the request is rejected or the data contains an error.\n   */\n  async processTallyStep({ messageId, signedData }) {\n    const result = await this.apolloClient.mutate({\n      mutation: PROCESS_TALLY_STEP,\n      variables: {\n        messageId,\n        signedData,\n      },\n    });\n\n    if (result.data.processTallyStep.error) {\n      throw new Error(result.data.processTallyStep.error);\n    }\n\n    return result.data.processTallyStep.pendingMessage;\n  }\n}\n","export const AUTHORITY_TYPE = \"a\";\nexport const BULLETIN_BOARD_TYPE = \"b\";\nexport const VOTER_TYPE = \"v\";\nexport const TRUSTEE_TYPE = \"t\";\nexport const VALID_TYPES = [\n  AUTHORITY_TYPE,\n  BULLETIN_BOARD_TYPE,\n  VOTER_TYPE,\n  TRUSTEE_TYPE,\n];\n\n/**\n * This is a class that handles message id strings.\n */\nexport class MessageIdentifier {\n  /**\n   * Parses a message id string into a JS object.\n   *\n   * @param {String} messageId - A string with a message id.\n   * @returns {Object} - An object with the message id values.\n   */\n  static parse(messageId) {\n    const [elements, author] = messageId.split(\"+\");\n    const [authority, electionId, type, subtype] = elements.split(\".\", 4);\n    const [authorType, authorId] = author.split(\".\", 2);\n    const dotSubtype = subtype ? `.${subtype}` : \"\";\n\n    if (!VALID_TYPES.includes(authorType)) {\n      throw new Error(\"Invalid message identifier format\");\n    }\n\n    return {\n      electionId: `${authority}.${electionId}`,\n      type,\n      subtype,\n      typeSubtype: `${type}${dotSubtype}`,\n      author: {\n        type: authorType,\n        id: authorId,\n      },\n    };\n  }\n\n  static format(electionId, typeSubtype, authorType, authorId) {\n    return `${electionId}.${typeSubtype}+${authorType}.${authorId}`;\n  }\n}\n","import { JWS, JWK } from \"node-jose\";\nimport {\n  MessageIdentifier,\n  AUTHORITY_TYPE,\n  BULLETIN_BOARD_TYPE,\n  TRUSTEE_TYPE,\n} from \"./message-identifier\";\nimport { samePublicKeys } from \"../utils\";\n\n/**\n * Verify and parses JWT tokens.\n */\nexport class MessageParser {\n  /**\n   * Initializes the class with the given params.\n   *\n   * @constructor\n   * @param {Object} params - An object that contains the initialization params.\n   * - {String} authorityPublicKeyJSON - The public key of the authority\n   */\n  constructor({ authorityPublicKeyJSON }) {\n    this.authorityPublicKeyJSON = authorityPublicKeyJSON;\n    this.authorityPublicKey = JWK.asKey(authorityPublicKeyJSON, \"json\");\n    this.keys = null;\n  }\n\n  /**\n   * Parses the given token only if it can be verified.\n   *\n   * @param {String} token - A JWT token.\n   * @returns {Promise<Object>} - The payload included in the token.\n   * @throws An error is thrown if the payload is not a valid JSON or the token\n   *         cannot be verified.\n   */\n  async parse({ messageId, signedData }) {\n    const messageIdentifier = MessageIdentifier.parse(messageId);\n    const senderKey = await (this.keys\n      ? this.keys[messageIdentifier.author.type][messageIdentifier.author.id]\n      : this.authorityPublicKey);\n\n    if (!signedData) {\n      return { messageIdentifier, decodedData: null };\n    }\n\n    const result = await JWS.createVerify(senderKey).verify(signedData, {\n      algorithms: [\"RS256\"],\n    });\n\n    const decodedData = JSON.parse(\n      new TextDecoder(\"utf-8\").decode(result.payload)\n    );\n\n    if (!this.keys) {\n      this.keys = await this.parseCreateElection(decodedData);\n    }\n\n    return { messageIdentifier, decodedData };\n  }\n\n  /* eslint-disable camelcase */\n  async parseCreateElection({ authority, bulletin_board, trustees }) {\n    if (!samePublicKeys(authority.public_key, this.authorityPublicKeyJSON)) {\n      throw new Error(\n        \"The authority public key doesn't match the election's authority public key.\"\n      );\n    }\n\n    const result = {\n      [AUTHORITY_TYPE]: { [authority.slug]: this.authorityPublicKey },\n      [BULLETIN_BOARD_TYPE]: {},\n      [TRUSTEE_TYPE]: {},\n    };\n\n    const promises = [];\n    promises.push(\n      this.loadKey(bulletin_board).then((key) => {\n        result[BULLETIN_BOARD_TYPE][bulletin_board.slug] = key;\n      })\n    );\n    for (const trustee of trustees) {\n      promises.push(\n        this.loadKey(trustee).then((key) => {\n          result[TRUSTEE_TYPE][trustee.slug] = key;\n        })\n      );\n    }\n\n    await Promise.all(promises);\n\n    return result;\n  }\n  /* eslint-enable camelcase */\n\n  loadKey(client) {\n    return JWK.asKey(client.public_key, \"json\");\n  }\n}\n","import { MessageIdentifier, TRUSTEE_TYPE } from \"../client/message-identifier\";\n\nexport const WAIT_TIME_MS = 2_000; // 2s\n\n/**\n * Handles the election state and includes some methods to interact with the election log.\n */\nexport class Election {\n  /**\n   * Initializes the class with the given params.\n   *\n   * @constructor\n   * @param {Object} params - An object that contains the initialization params.\n   *  - {String} uniqueId - The unique identifier of an election.\n   *  - {Client} bulletinBoardClient - An instance of the Bulletin Board Client\n   *  - {Array<String>} typesFilter - The list of type of messages to retrieve.\n   *  - {Object?} options - An optional object with some extra options.\n   */\n  constructor({ uniqueId, bulletinBoardClient, typesFilter, options }) {\n    this.uniqueId = uniqueId;\n    this.bulletinBoardClient = bulletinBoardClient;\n    this.logEntries = [];\n    this.typesFilter = typesFilter;\n    this.subscriptionId = null;\n    this.options = options || { waitUntilNextCheck: WAIT_TIME_MS };\n  }\n\n  /**\n   * Store the election log entries and periodically check if there are new entries.\n   *\n   * @returns {Promise<undefined>}\n   */\n  async subscribeToLogEntriesChanges() {\n    this.unsubscribeToLogEntriesChanges();\n\n    // Ensure that we get the current log entries before starting the subscription.\n    await this.getLogEntries();\n\n    this.subscriptionId = setInterval(() => {\n      this.getLogEntries();\n    }, this.options.waitUntilNextCheck);\n  }\n\n  /**\n   * Clear the periodically checks of new log entries.\n   *\n   * @returns {undefined}\n   */\n  unsubscribeToLogEntriesChanges() {\n    if (this.subscriptionId !== null) {\n      clearInterval(this.subscriptionId);\n      this.subscriptionId = null;\n    }\n  }\n\n  /**\n   * Return the last message stored in the log sent by the given trustee.\n   *\n   * @param {String} trusteeId - The unique identifier of a trustee.\n   * @returns {Object|null}\n   */\n  getLastMessageFromTrustee(trusteeId) {\n    for (let i = this.logEntries.length - 1; i >= 0; i--) {\n      const logEntry = this.logEntries[i];\n      const messageIdentifier = MessageIdentifier.parse(logEntry.messageId);\n      if (\n        messageIdentifier.author.type === TRUSTEE_TYPE &&\n        messageIdentifier.author.id === trusteeId\n      ) {\n        return logEntry;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Uses the bulletin board client to get all the election log entries after the\n   * last log entry stored in the election's state.\n   *\n   * @private\n   * @returns {Promise<nothing>}\n   */\n  getLogEntries() {\n    const lastLogEntry = this.logEntries[this.logEntries.length - 1];\n    const after = (lastLogEntry && lastLogEntry.id) || null;\n\n    return new Promise((resolve) => {\n      this.bulletinBoardClient\n        .getElectionLogEntries({\n          electionUniqueId: this.uniqueId,\n          after,\n          types: this.typesFilter,\n        })\n        .then((logEntries) => {\n          if (logEntries.length) {\n            this.logEntries = [...this.logEntries, ...logEntries];\n          }\n          resolve();\n        });\n    });\n  }\n}\n","import { Client } from \"../client/client\";\nimport { Election } from \"../election/election\";\nimport { Voter } from \"../voter/voter\";\n\n/**\n * This class is used to bind any UI elements to a vote process.\n */\nexport class VoteComponent {\n  /**\n   * Initialises the class with the given params.\n   * @param {Object} params - An object that contains the initialization params.\n   *  - {Object} bulletinBoardClientParams - An object to configure the bulletin board client.\n   *  - {String} authorityPublicKeyJSON - The authority identification public key.\n   *  - {String} electionUniqueId - The unique identifier of an election.\n   *  - {String} voterUniqueId - The unique identifier of a voter.\n   *  - {Object} voterWrapperAdapter - An object to interact with the voter wrapper.\n   * @constructor\n   */\n  constructor({\n    bulletinBoardClientParams,\n    authorityPublicKeyJSON,\n    electionUniqueId,\n    voterUniqueId,\n    voterWrapperAdapter,\n  }) {\n    this.bulletinBoardClient = new Client(bulletinBoardClientParams);\n\n    const election = new Election({\n      uniqueId: electionUniqueId,\n      bulletinBoardClient: this.bulletinBoardClient,\n    });\n\n    this.voter = new Voter({\n      bulletinBoardClient: this.bulletinBoardClient,\n      authorityPublicKeyJSON,\n      election,\n      uniqueId: voterUniqueId,\n      wrapperAdapter: voterWrapperAdapter,\n    });\n  }\n\n  /**\n   * Bind UI events to the vote process.\n   *\n   * @method bindEvents\n   * @param {Object} eventCallbacks - An object that contains event callback functions.\n   * - {Function} onBindEncryptButton - a function that receives a callback function that will be called when encrypting the vote must be started\n   * - {Function} onVoteEncryption - a function that is called when the vote gets encrypted\n   * - {Function} castOrAuditBallot - a function that is called to cast or audit a ballot\n   * - {Function} onStart - a function that is called when the vote has started.\n   * - {Function} onBindAuditBallotButton - a function that called when the ballot should get audited\n   * - {Function} onBindCastBallotButton - a function that called when the ballot should get casted\n   * - {Function} onAuditBallot - a function that is called to audit a vote before encrypting it.\n   * - {Function} onAuditComplete - a function that is called when the auditable vote is audited.\n   * - {Function} onCastBallot - a function that is called to cast the ballot.\n   * - {Function} onCastComplete - a function that is called when the vote is casted.\n   * - {Function} onInvalid - a function that is called when the vote is not valid.\n   *\n   * @returns {Promise<undefined>}\n   */\n  async bindEvents({\n    onBindEncryptButton,\n    onStart,\n    onVoteEncryption,\n    castOrAuditBallot,\n    onBindAuditBallotButton,\n    onBindCastBallotButton,\n    onAuditBallot,\n    onCastBallot,\n    onAuditComplete,\n    onCastComplete,\n    onInvalid,\n  }) {\n    const onSetupDone = this.voter.setup();\n\n    onBindEncryptButton(async () => {\n      onStart();\n      await onSetupDone;\n      onVoteEncryption(\n        (plainVote, ballotStyle) => {\n          this.voter.encrypt(plainVote, ballotStyle).then((ballot) => {\n            castOrAuditBallot(ballot);\n            onBindAuditBallotButton(() => {\n              onAuditBallot(\n                ballot,\n                `${this.voter.uniqueId}-election-${this.voter.election.uniqueId}.txt`\n              );\n              onAuditComplete();\n            });\n\n            onBindCastBallotButton(async () => {\n              try {\n                const result = await onCastBallot(ballot);\n                onCastComplete(result);\n              } catch {\n                onInvalid();\n              }\n            });\n          });\n        },\n        () => {\n          onInvalid();\n        }\n      );\n    });\n  }\n}\n","import { MessageParser } from \"../client/message-parser\";\n\n/**\n * This is a facade class that will use the corresponding `VoterWrapper` to encrypt\n * the vote.\n */\nexport class Voter {\n  /**\n   * Initializes the class with the given params.\n   *\n   * @constructor\n   * @param {Object} params - An object that contains the initialization params.\n   *  - {Client} bulletinBoardClient - An instance of the Bulletin Board Client.\n   *  - {String} authorityPublicKeyJSON - The authority identification public key.\n   *  - {Object} election - An object that interacts with a specific election\n   *                        to get some data and perform the vote.\n   *  - {String} uniqueId - The voter identifier.\n   *  - {Object} wrapperAdapter - An object to interact with the voter wrapper.\n   */\n  constructor({\n    bulletinBoardClient,\n    authorityPublicKeyJSON,\n    election,\n    uniqueId,\n    wrapperAdapter,\n  }) {\n    this.uniqueId = uniqueId;\n    this.election = election;\n    this.bulletinBoardClient = bulletinBoardClient;\n    this.wrapperAdapter = wrapperAdapter;\n    this.parser = new MessageParser({ authorityPublicKeyJSON });\n  }\n\n  /**\n   * Performs some operations to setup the voter.\n   *\n   * Retrieves the key ceremony messages needed to cast a vote in the given election.\n   *\n   * @returns {Promise<undefined>}\n   */\n  async setup() {\n    await this.wrapperAdapter.setup();\n    return this.bulletinBoardClient\n      .getElectionLogEntries({\n        electionUniqueId: this.election.uniqueId,\n        types: [\"create_election\", \"end_key_ceremony\"],\n      })\n      .then(async (logEntries) => {\n        for (const logEntry of logEntries) {\n          const { messageIdentifier, decodedData } = await this.parser.parse(\n            logEntry\n          );\n\n          await this.wrapperAdapter.processMessage(\n            messageIdentifier.typeSubtype,\n            decodedData\n          );\n        }\n      });\n  }\n\n  /**\n   * Encrypts the data using the wrapper.\n   *\n   * @param {Object} plainVote - An object with the choosen answers for each question.\n   * @param {String} ballotStyle - The ballot style identifier.\n   *\n   * @returns {Promise<Object>} - The ballot.\n   */\n  async encrypt(plainVote, ballotStyle) {\n    const { encryptedData, auditableData } = await this.wrapperAdapter.encrypt(\n      plainVote,\n      ballotStyle\n    );\n    const encryptedDataHash = await this.hash(encryptedData);\n\n    return {\n      encryptedData,\n      encryptedDataHash,\n      auditableData,\n      plainVote,\n      electionUniqueId: this.election.uniqueId,\n    };\n  }\n\n  /**\n   * Generates the hash from the given data.\n   *\n   * @private\n   * @param {Object} data - The data to be digested.\n   * @returns {Promise<Object>} - The hash value.\n   */\n  async hash(data) {\n    return window.crypto.subtle\n      .digest(\"SHA-256\", new TextEncoder().encode(data))\n      .then((hashBuffer) => {\n        const hashArray = Array.from(new Uint8Array(hashBuffer));\n        return hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n      });\n  }\n\n  /**\n   * Verifies a vote\n   *\n   * @param {String} contentHash - An object that includes the following options.\n   *  - {String} contentHash - the contentHash of a vote\n   * @returns {Promise<Object>} - Returns a logEntry\n   */\n  verifyVote(contentHash) {\n    const { uniqueId: electionUniqueId } = this.election;\n\n    return this.bulletinBoardClient.getLogEntry({\n      electionUniqueId,\n      contentHash,\n    });\n  }\n}\n","export const CREATE_ELECTION = \"create_election\";\nexport const END_KEY_CEREMONY = \"end_key_ceremony\";\n\n/**\n * This is just a dummy implementation of a possible `VoterWrapper`.\n * It is based on the dummy voting schema that we are using in the Bulletin Board.\n */\n\nexport const WAIT_TIME_MS = 500; // 0.5s\n\nexport class VoterWrapper {\n  constructor({ voterId, waitTime }) {\n    this.voterId = voterId;\n    this.jointElectionKey = null;\n    this.contests = {};\n    this.waitTime = waitTime ?? WAIT_TIME_MS;\n  }\n\n  /**\n   * Process the message and update the wrapper status.\n   *\n   * @param {String} messageType - The message type.\n   * @param {Object} decodedData - An object with the data to process.\n   *\n   * @returns {undefined}\n   */\n  processMessage(messageType, decodedData) {\n    switch (messageType) {\n      case CREATE_ELECTION: {\n        this.contests = decodedData.description.contests;\n        break;\n      }\n      case END_KEY_CEREMONY: {\n        const content = JSON.parse(decodedData.content);\n        this.jointElectionKey = content.joint_election_key;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Converts the given vote into an auditable ballot and an encrypted Ballot. As the process is very fast,\n   * it simulates the delay of the encryption process.\n   *\n   * @param {Object} plainVote - An object with the choosen answers for each question.\n   * @param {String} ballotStyle - The ballot style identifier.\n   *\n   * @private\n   * @returns {Promise<Object|undefined>}\n   */\n  async encrypt(plainVote, _ballotStyle) {\n    return new Promise((resolve) => setTimeout(resolve, WAIT_TIME_MS)).then(\n      () => {\n        if (!this.jointElectionKey) {\n          console.warn(\"Invalid election status.\");\n          return;\n        }\n\n        const auditableData = this.createAuditableBallot(plainVote);\n        const encryptedData = JSON.stringify(\n          this.createEncryptedData(JSON.parse(JSON.stringify(auditableData)))\n        );\n\n        return { auditableData, encryptedData };\n      }\n    );\n  }\n\n  /**\n   * Encrypts the given vote into an object with the format expected by the Dummy voting scheme,\n   * using the silly encryption defined by the scheme for each answer ((1|0) + random * jointElectionKey).\n   * Returns the auditable vote.\n   *\n   * @param {Object} vote - An object with the choosen answers for each question.\n   *\n   * @private\n   * @returns {<Object>}\n   */\n  createAuditableBallot(vote) {\n    /* eslint-disable camelcase */\n    return {\n      ballot_style: \"ballot-style\",\n      contests: this.contests.map(({ object_id, ballot_selections }) => {\n        return {\n          object_id,\n          ballot_selections: ballot_selections.map((ballotSelection) => {\n            const random = Math.random();\n            const plaintext =\n              vote[object_id] &&\n              vote[object_id].includes(ballotSelection.object_id)\n                ? 1\n                : 0;\n\n            return {\n              object_id: ballotSelection.object_id,\n              ciphertext:\n                plaintext +\n                Math.floor(random * 500 + 1) * this.jointElectionKey,\n              random,\n              plaintext,\n            };\n          }),\n        };\n      }),\n    };\n    /* eslint-enable camelcase */\n  }\n\n  /**\n   * Creates an encrypted data.\n   *\n   * @param {Object} vote - An object with the encrypted vote.\n   *\n   * @private\n   * @returns {<Object>}\n   */\n  createEncryptedData(vote) {\n    const encryptedBallot = this.removeAuditInformation(vote);\n    return encryptedBallot;\n  }\n\n  /**\n   * Removes the 'random' and 'plaintext' fields from the auditable ballot.\n   *\n   * @param {Object} ballot - An auditable ballot.\n   *\n   * @private\n   * @returns {<Object>}\n   */\n  removeAuditInformation(ballot) {\n    /* eslint-disable camelcase */\n    ballot.contests.map((contest) => {\n      return contest.ballot_selections.map((ballot_selection) => {\n        delete ballot_selection.random;\n        delete ballot_selection.plaintext;\n\n        return ballot_selection;\n      });\n    });\n\n    return ballot;\n    /* eslint-enable camelcase */\n  }\n}\n","import { VoterWrapper } from \"./voter_wrapper\";\n\n/**\n * This is just a dummy implementation of a possible `VoterWrapperAdapter`.\n * It is based on the dummy voting scheme that we are using in the Bulletin Board.\n */\nexport class VoterWrapperAdapter {\n  /**\n   * Initializes the class with the given params.\n   *\n   * @constructor\n   * @param {Object} params - An object that contains the initialization params.\n   * - {String} voterId - The unique id of a trustee.\n   * - {String} waitTime - The time to wait to simulate the real encryption time.\n   * -\n   */\n  constructor({ voterId, waitTime }) {\n    this.voterId = voterId;\n    this.wrapper = new VoterWrapper({ voterId, waitTime });\n  }\n\n  /**\n   * Setup the voter wrapper.\n   *\n   * @returns {Promise<undefined>}\n   */\n  setup() {}\n\n  /**\n   * Processes the message and updates the wrapper status.\n   *\n   * @param {String} messageType - The message type.\n   * @param {Object} decodedData - An object with the data to process.\n   *\n   * @returns {Promise<Object|undefined>}\n   */\n  processMessage(messageType, decodedData) {\n    return this.wrapper.processMessage(messageType, decodedData);\n  }\n\n  /**\n   * Encrypts the plain vote using the wrapper and returns an object with the\n   * encrypted data and the auditable data known as ballot.\n   *\n   * @param {Object} plainVote - An object with the choosen answers for each question.\n   * @param {String} ballotStyle - The ballot style identifier.\n   *\n   * @private\n   * @returns {Promise<Object|undefined>}\n   */\n  encrypt(plainVote, ballotStyle) {\n    return this.wrapper.encrypt(plainVote, ballotStyle);\n  }\n}\n","/**\n * Common class used by any ElectionGuard adapter to run python code through web workers.\n */\nexport class WrapperAdapter {\n  /**\n   * Runs an arbitrary python code in the web worker.\n   *\n   * @param {String} pythonCode - A string representing valid python code.\n   * @param {Object} pythonData - An Object which values can be referenced from\n   *                              the python code using the js module.\n   * @private\n   * @returns {Promise<Object>}\n   */\n  processPythonCodeOnWorker(pythonCode, pythonData) {\n    return new Promise((resolve, reject) => {\n      this.worker.onmessage = (event) => {\n        resolve(event.data.results);\n      };\n\n      this.worker.onerror = (error) => {\n        console.error(error);\n        reject(error);\n      };\n\n      this.worker.postMessage({\n        python: pythonCode,\n        ...pythonData,\n      });\n    });\n  }\n}\n","import { WrapperAdapter } from \"./wrapper_adapter\";\n\n/**\n * This implements the Electionguard Voter Wrapper Adapter using a web worker\n * that executes python code compiled through `pyodide`.\n * @extends WrapperAdapter\n */\nexport class VoterWrapperAdapter extends WrapperAdapter {\n  /**\n   * Initializes the class with the given params.\n   *\n   * @constructor\n   * @param {Object} params - An object that contains the initialization params.\n   * - {String} voterId - The unique id of a voter.\n   */\n  constructor({ voterId, workerUrl }) {\n    super();\n\n    this.voterId = voterId;\n    this.worker = new Worker(workerUrl);\n  }\n\n  /**\n   * Setup the voter wrapper.\n   *\n   * @returns {Promise<undefined>}\n   */\n  setup() {\n    return this.processPythonCodeOnWorker(\n      `\n        from js import voter_id\n        from bulletin_board.electionguard.voter import Voter\n        voter = Voter(voter_id)\n      `,\n      {\n        voter_id: this.voterId,\n      }\n    );\n  }\n\n  /**\n   * Process the message and update the wrapper status.\n   *\n   * @param {String} messageType - The message type.\n   * @param {Object} decodedData - An object with the data to process.\n   *\n   * @returns {Promise<Object|undefined>}\n   */\n  async processMessage(messageType, decodedData) {\n    const result = await this.processPythonCodeOnWorker(\n      `\n      import json\n      from js import message_type, decoded_data\n      voter.process_message(message_type, json.loads(decoded_data))\n    `,\n      {\n        message_type: messageType,\n        decoded_data: JSON.stringify(decodedData),\n      }\n    );\n\n    if (result && result[0]) {\n      // eslint-disable-next-line camelcase\n      const { message_type, content } = result[0];\n      return {\n        messageType: message_type,\n        content,\n      };\n    }\n  }\n\n  /**\n   * Encrypts the plain vote using the wrapper and returns an object with the\n   * encrypted data and the auditable data known as ballot.\n   *\n   * @param {Object} plainVote - An object with the choosen answers for each question.\n   * @param {String} ballotStyle - The ballot style identifier.\n   *\n   * @private\n   * @returns {Promise<Object|undefined>}\n   */\n  async encrypt(plainVote, ballotStyle) {\n    const [auditableData, encryptedData] = await this.processPythonCodeOnWorker(\n      `\n      from js import plain_vote, ballot_style\n      voter.encrypt(plain_vote, ballot_style)\n    `,\n      {\n        plain_vote: plainVote,\n        ballot_style: ballotStyle,\n      }\n    );\n\n    return { auditableData, encryptedData };\n  }\n}\n"],"names":["GraphQLClient","constructor","apiEndpointUrl","headers","httpLink","uri","this","apolloClient","link","cache","async","electionUniqueId","contentHash","query","variables","data","logEntry","after","types","fetchPolicy","election","logEntries","messageId","signedData","result","mutate","mutation","processKeyCeremonyStep","error","Error","pendingMessage","processTallyStep","AUTHORITY_TYPE","BULLETIN_BOARD_TYPE","TRUSTEE_TYPE","VALID_TYPES","MessageIdentifier","static","elements","author","split","authority","electionId","type","subtype","authorType","authorId","dotSubtype","includes","typeSubtype","id","MessageParser","authorityPublicKeyJSON","authorityPublicKey","JWK","keys","messageIdentifier","senderKey","decodedData","JWS","verify","algorithms","JSON","parse","TextDecoder","decode","payload","parseCreateElection","bulletin_board","trustees","public_key","slug","promises","push","loadKey","then","key","trustee","Promise","all","client","Election","uniqueId","bulletinBoardClient","typesFilter","options","subscriptionId","waitUntilNextCheck","unsubscribeToLogEntriesChanges","getLogEntries","setInterval","clearInterval","getLastMessageFromTrustee","trusteeId","i","length","lastLogEntry","resolve","getElectionLogEntries","VoteComponent","bulletinBoardClientParams","voterUniqueId","voterWrapperAdapter","voter","wrapperAdapter","onBindEncryptButton","onStart","onVoteEncryption","castOrAuditBallot","onBindAuditBallotButton","onBindCastBallotButton","onAuditBallot","onCastBallot","onAuditComplete","onCastComplete","onInvalid","onSetupDone","setup","plainVote","ballotStyle","encrypt","ballot","Voter","parser","processMessage","encryptedData","auditableData","encryptedDataHash","hash","window","crypto","subtle","digest","TextEncoder","encode","hashBuffer","Array","from","Uint8Array","map","b","toString","padStart","join","verifyVote","getLogEntry","VoterWrapper","voterId","waitTime","jointElectionKey","contests","messageType","description","content","joint_election_key","_ballotStyle","setTimeout","console","warn","createAuditableBallot","stringify","createEncryptedData","vote","ballot_style","object_id","ballot_selections","ballotSelection","random","Math","plaintext","ciphertext","floor","removeAuditInformation","contest","ballot_selection","VoterWrapperAdapter","wrapper","WrapperAdapter","processPythonCodeOnWorker","pythonCode","pythonData","reject","worker","onmessage","event","results","onerror","postMessage","python","workerUrl","super","Worker","voter_id","message_type","decoded_data","plain_vote"],"sourceRoot":""}